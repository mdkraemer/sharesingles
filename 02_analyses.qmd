---
title: "Singlehood SHARE: Analyses Overview"
author: "Michael Krämer"
toc: true
toc-depth: 5
toc-title: Contents
number-sections: true
execute:
  cache: true
format:
#  docx:
#    highlight-style: github
  html:
    link-external-icon: true
    link-external-newwindow: true
    code-block-bg: true
    code-block-border-left: "#31BAE9"
    embed-resources: true
#comments:
#  hypothesis: true
editor: source
#bibliography: references-zotero.bib
#csl: apa.csl
---
<!--
You can find the preregistration [here](https://osf.io/xbua4).
-->

## Load packages

```{r}
#| echo: true
#| warning: false
#| code-fold: true
#| code-summary: "Show the code"
#| cache: false
library(renv)
library(tidyverse)
library(broom)
library(labelled)
library(psych)
library(quest) # for POMP scores
library(GPArotation)
library(specr)
library(lme4)
library(lmerTest)
library(furrr)
library(knitr)
library(performance)
library(Hmisc)
library(corrplot)
```

## Load cleaned data

```{r}
#| echo: true
#| warning: false
#| output: false
#| code-fold: true
#| code-summary: "Show the code"
#| cache: true
base::load("data/01_cleaned/df_singles.rda")
df_singles <- data_prepped
```

## More data cleaning

```{r}
#| echo: true
#| warning: false
#| output: false
#| code-fold: true
#| code-summary: "Show the code"
#| cache: true
df_singles <- df_singles %>% group_by(mergeid) %>% mutate(pid = cur_group_id()) %>% ungroup() %>% 
  mutate(age_c = age - mean(age, na.rm=T))

# rename for easier to interpret var names
df_singles <- df_singles %>% 
  rename(extraversion = bfi10_extra, agreeableness = bfi10_agree, conscientiousness = bfi10_consc, 
         neuroticism = bfi10_neuro, openness = bfi10_open,
         ever_partnered = everlat, ever_cohabitating = evercohab, ever_married = evermarried, 
         life_satisfaction = ac012_, quality_of_life = casp, income = thinc2)
# code education
df_singles <- df_singles %>% 
  mutate(education = case_when(
    isced1997_r == 1 ~ "ISCED_1",
    isced1997_r == 2 ~ "ISCED_2",
    isced1997_r == 3 ~ "ISCED_3",
    isced1997_r == 4 ~ "ISCED_4",
    isced1997_r == 5 ~ "ISCED_5",
    isced1997_r == 6 ~ "ISCED_6",
    isced1997_r %in% c(0, 95, 96) ~ "other/none",
    .default = NA_character_
  )) %>% # also dummy coding (1 = reference category)
  mutate(isced_2 = ifelse(!is.na(education), ifelse(education=="ISCED_2", 1, 0), NA),
         isced_3 = ifelse(!is.na(education), ifelse(education=="ISCED_3", 1, 0), NA),
         isced_4 = ifelse(!is.na(education), ifelse(education=="ISCED_4", 1, 0), NA),
         isced_5 = ifelse(!is.na(education), ifelse(education=="ISCED_5", 1, 0), NA),
         isced_6 = ifelse(!is.na(education), ifelse(education=="ISCED_6", 1, 0), NA),
         isced_other = ifelse(!is.na(education), ifelse(education=="other/none", 1, 0), NA)) %>% 
  mutate(income_z = scale(income)) # z-standardize income

# switch 0/1 dummy coding for predictors
df_singles <- df_singles %>% 
  mutate(never_partnered = if_else(ever_partnered==1, 0, ifelse(ever_partnered==0, 1, NA)),
         never_cohabitating = if_else(ever_cohabitating==1, 0, ifelse(ever_cohabitating==0, 1, NA)),
         never_married = if_else(ever_married==1, 0, ifelse(ever_married==0, 1, NA)))
```

### Reliability CASP-12

```{r}
#| echo: true
#| warning: false
#| output: true
#| cache: true

# recode all CASP-items so that higher values relate to better well-being. right now it is:
# 1 [Often]   
# 2 [Sometimes]
# 3 [Rarely]  
# 4 [Never]   
df_singles <- df_singles %>% 
  mutate(across(starts_with("casp"), ~ max(.x, na.rm=T) - .x + 1))

# count missings
df_singles <- df_singles %>% 
  rowwise %>% 
  mutate(na_casp = sum(is.na(across(starts_with("casp"))))) %>% 
  ungroup()

# Cronbach's alpha
alpha_casp <- df_singles %>% 
  dplyr::select(starts_with("casp")) %>%
  psych::alpha(check.keys = TRUE)
alpha_casp$total
# Omega
omega_casp <- df_singles %>% 
  dplyr::select(starts_with("casp")) %>% 
  psych::omega(m = ., keys = alpha_casp$keys, plot = FALSE, nfactors=4)
omega_casp$omega_h
omega_casp$omega.tot
# add scored variable
df_singles$casp <- df_singles %>%
  select(starts_with("casp")) %>%
  psych::reverse.code(keys=alpha_casp$keys[[1]], items = .) %>%
  rowSums(na.rm=T)

df_singles <- df_singles %>% 
  mutate(casp_all = ifelse(na_casp>0, NA, casp), # same as in generated var: score is NA if one or more items are NA
         casp_alt = ifelse(na_casp>4, NA, casp)) # alternative: score is NA if more than 4 items are NA
summary(df_singles$casp_all) # same as generated variable 
summary(df_singles$quality_of_life)

summary(df_singles$casp_alt) # 4111 less NA!
```

### Winsorize variables

```{r}
#| echo: true
#| warning: false
#| output: true
#| code-fold: true
#| code-summary: "Show the code"
#| cache: true

# winsorizing of outliers (code from Yannick Roos):
# calculate means and standard deviations
means <- sapply(df_singles[, c("extraversion", "agreeableness", "conscientiousness", "neuroticism", "openness",
                               "life_satisfaction", "quality_of_life", "casp_alt")], mean, na.rm = TRUE)
sds <- sapply(df_singles[, c("extraversion", "agreeableness", "conscientiousness", "neuroticism", "openness",
                             "life_satisfaction", "quality_of_life", "casp_alt")], sd, na.rm = TRUE)

# combine results into a data frame
result_df <- data.frame(variable = names(means), mean = round(means,digits = 2), sd = round(sds,digits = 2))

# detect outliers and winsorize as necessary
for (col_name in c("extraversion", "agreeableness", "conscientiousness", "neuroticism", "openness",
                    "life_satisfaction", "quality_of_life", "casp_alt")) {
  # detect outliers
  outlier_indices <- which(df_singles[, col_name] < means[col_name] - 3 * sds[col_name] |
                             df_singles[, col_name] > means[col_name] + 3 * sds[col_name])
  
  # winsorize if necessary
  if (length(outlier_indices) > 0) {
    print(paste(col_name, "has", length(outlier_indices),"outlier(s)"))
    # create a new column with the winsorized values
    winsorized_col_name <- paste0(col_name, "_w")
    df_singles[winsorized_col_name] <- df_singles[, col_name]
    df_singles[winsorized_col_name][df_singles[winsorized_col_name] < means[col_name] - 3 * sds[col_name]] <- means[col_name] - 3 * sds[col_name]
    df_singles[winsorized_col_name][df_singles[winsorized_col_name] > means[col_name] + 3 * sds[col_name]] <- means[col_name] + 3 * sds[col_name]
  }
}
```

### Rescale variables

```{r}
#| echo: true
#| warning: false
#| output: false
#| code-fold: true
#| code-summary: "Show the code"
#| cache: true

# POMP scores for well-being (because scale is very different across the two!)
df_singles <- df_singles %>% 
  mutate(life_satisfaction_p = quest::pomp(life_satisfaction_w, mini=0, maxi=10, relative = FALSE, unit = 1),
         quality_of_life_p = quest::pomp(quality_of_life_w, mini=12, maxi=48, relative = FALSE, unit = 1),
         casp_alt_p = quest::pomp(casp_alt, mini=12, maxi=48, relative = FALSE, unit = 1))
```

### Merge country-level data

```{r}
#| echo: true
#| warning: false
#| output: false
#| code-fold: true
#| code-summary: "Show the code"
#| cache: true
df_singles <- df_singles %>% group_by(mergeid) %>% mutate(pid = cur_group_id()) %>% ungroup() %>% 
  mutate(country_str = as.character(haven::as_factor(country)))
df_singles$country_str <- sub(" ", "_", df_singles$country_str) # for Czech Republic

df_country_level <- read_csv2("country_data.csv") %>% rename(country_str = Country)

df_singles <- df_singles %>% left_join(df_country_level)

df_singles <- df_singles %>% 
  rename(religiosity = Religiosity, gender_ratio = `Gender_ratio(maleper100female)`, 
         singles_proportion = Total_Singlehood_Ratio) %>% 
  mutate(religiosity_z = scale(religiosity), # z-standardize 
         gender_ratio_z = scale(gender_ratio),
         singles_proportion_z = scale(singles_proportion))

# labelled variable types sometimes cause problems donwstream -> convert to numeric
df_singles <- df_singles %>% mutate_at(c("extraversion", "agreeableness_w", "conscientiousness_w", "neuroticism", "openness",
                                         "life_satisfaction_p", "quality_of_life_p"), as.numeric)
```
## Descriptives

### Sample size

*How many participants do we have in total / in each group (never married/ never cohabitating/ never partnered)?* 

```{r}
#| echo: true
# for all participants 
df_singles %>% filter(!is.na(never_partnered) | !is.na(never_cohabitating) | !is.na(never_married)) %>% tally()

# never partnered (0 = no, 1 = yes)
df_singles %>% group_by(never_partnered) %>% tally()

# never cohabitating (0 = no, 1 = yes)
df_singles %>% group_by(never_cohabitating) %>% tally()

# never partnered (0 = no, 1 = yes)
df_singles %>% group_by(never_married) %>% tally()
```

However, there are additional missings in both the outcome variables and some of the covariates (335 missings for education). You can see in the "Results summary" section (5.1) how many observations each specification was based on (in the *fit_nobs* column).

------------------------------------------------------------------------

### Age

*How old are they?*

```{r}
#| echo: true
# for all participants 
df_singles %>% filter(!is.na(never_partnered) | !is.na(never_cohabitating) | !is.na(never_married)) %>% 
  summarise(mean_age = mean(age, na.rm=T), sd_age = sd(age, na.rm=T), 
            min_age = min(age, na.rm=T), max_age = max(age, na.rm=T))

# never partnered (0 = no, 1 = yes)
df_singles %>% group_by(never_partnered) %>% 
  summarise(mean_age = mean(age, na.rm=T), sd_age = sd(age, na.rm=T), 
            min_age = min(age, na.rm=T), max_age = max(age, na.rm=T))

# never cohabitating (0 = no, 1 = yes)
df_singles %>% group_by(never_cohabitating) %>% 
  summarise(mean_age = mean(age, na.rm=T), sd_age = sd(age, na.rm=T), 
            min_age = min(age, na.rm=T), max_age = max(age, na.rm=T))

# never partnered (0 = no, 1 = yes)
df_singles %>% group_by(never_married) %>% 
  summarise(mean_age = mean(age, na.rm=T), sd_age = sd(age, na.rm=T), 
            min_age = min(age, na.rm=T), max_age = max(age, na.rm=T))
```

What explains the low minimum age? -> Younger partners of older household heads! 

Only look at those under 50: How many?
```{r}
#| echo: true
# for all participants 
df_singles %>% filter(age<50 & (!is.na(never_partnered) | !is.na(never_cohabitating) | !is.na(never_married))) %>% 
  summarise(n = n(), mean_age = mean(age, na.rm=T), sd_age = sd(age, na.rm=T), 
            min_age = min(age, na.rm=T), max_age = max(age, na.rm=T))

# never partnered (0 = no, 1 = yes)
df_singles %>% filter(age<50) %>% group_by(never_partnered) %>% 
  summarise(n = n(), mean_age = mean(age, na.rm=T), sd_age = sd(age, na.rm=T), 
            min_age = min(age, na.rm=T), max_age = max(age, na.rm=T))

# never cohabitating (0 = no, 1 = yes)
df_singles %>% filter(age<50) %>% group_by(never_cohabitating) %>% 
  summarise(n = n(), mean_age = mean(age, na.rm=T), sd_age = sd(age, na.rm=T), 
            min_age = min(age, na.rm=T), max_age = max(age, na.rm=T))

# never partnered (0 = no, 1 = yes)
df_singles %>% filter(age<50) %>% group_by(never_married) %>% 
  summarise(n = n(), mean_age = mean(age, na.rm=T), sd_age = sd(age, na.rm=T), 
            min_age = min(age, na.rm=T), max_age = max(age, na.rm=T))
```

------------------------------------------------------------------------

### Gender 

*Gender ratios in each group?*

```{r}
#| echo: true
# for all participants 
df_singles %>% filter(!is.na(never_partnered) | !is.na(never_cohabitating) | !is.na(never_married)) %>% 
  group_by(female) %>% tally()
df_singles %>% filter(!is.na(never_partnered) | !is.na(never_cohabitating) | !is.na(never_married)) %>% 
  summarise(n = n(), prop_female = mean(female, na.rm=T)*100)

# never partnered (0 = no, 1 = yes)
df_singles %>% group_by(never_partnered, female) %>% tally()
df_singles %>% group_by(never_partnered) %>% summarise(n = n(), prop_female = mean(female, na.rm=T)*100)

# never cohabitating (0 = no, 1 = yes)
df_singles %>% group_by(never_cohabitating, female) %>% tally()
df_singles %>% group_by(never_cohabitating) %>% summarise(n = n(), prop_female = mean(female, na.rm=T)*100)

# never partnered (0 = no, 1 = yes)
df_singles %>% group_by(never_married, female) %>% tally()
df_singles %>% group_by(never_married) %>% summarise(n = n(), prop_female = mean(female, na.rm=T)*100)
```

------------------------------------------------------------------------

### Across countries

*How many people from each country?*

```{r}
#| echo: true
# the last three columns show the proportions of singlehood (across the three different operationalizations)
df_singles %>% group_by(country_str) %>% summarise(n = n(), prop_female = mean(female, na.rm=T)*100, 
                                                   prop_nev_part = mean(never_partnered, na.rm=T)*100, 
                                                   prop_nev_cohab = mean(never_cohabitating, na.rm=T)*100, 
                                                   prop_nev_marr = mean(never_married, na.rm=T)*100) %>% 
  print(n=Inf)
```

Something weird is going on in Malta! 

### Correlation matrix

```{r}
#| echo: true
#| warning: false
#| output: true
#| code-fold: true
#| code-summary: "Show the code"
#| cache: true
vars = df_singles[, c("female", "age", "life_satisfaction_w", "quality_of_life_w", 
                      "agreeableness_w", "conscientiousness_w", "extraversion", "neuroticism", "openness",
                      "never_partnered", "never_cohabitating", "never_married")] %>% mutate_all(list(~ as.numeric(.)))
cormat <- Hmisc::rcorr(as.matrix(vars), type="pearson") # uses pairwise complete pairs
cormat <- cormat$r

rownames(cormat) <- c("Gender (1 = f.)", "Age","Life Satisfaction" , "Quality of Life", 
                      "Agreeableness", "Conscientiousness", "Extraversion", "Neuroticism", "Openness",
                      "Never partnered", "Never cohabitating", "Never married")
colnames(cormat) <- c("Gender (1 = f.)", "Age","Life Satisfaction" , "Quality of Life", 
                      "Agreeableness", "Conscientiousness", "Extraversion", "Neuroticism", "Openness",
                      "Never partnered", "Never cohabitating", "Never married")

round(cormat, 2)
```

Plot: Correlation matrix
```{r}
#| echo: true
#| fig-width: 9.5
#| fig-height: 7.5

corrplot::corrplot(cormat, type = "lower", order = "original", tl.col = "black", 
                   addCoef.col ='black', number.cex = 0.7, diag = F) # also add numbers
```

------------------------------------------------------------------------

## Confirmatory results

### Specification curve analyses (SCA) {#sca}

Run SCA:
```{r}
#| echo: true
#| warning: false
#| output: false
#| code-fold: true
#| code-summary: "Show the code"
#| cache: true

specifications_b5 <- crossing(
  vec_outcome = c("extraversion", "agreeableness_w", "conscientiousness_w", "neuroticism", "openness"), 
  vec_predictor = c("never_partnered", "never_cohabitating", "never_married"),
  vec_controls = c("none", "age", "gender", "income", "education", "religiosity", "gender_ratio", "singles_proportion", "all")) %>% 
  mutate(specnr = row_number()) %>% 
  mutate(spec_name = paste0("outcome=", vec_outcome, ", predictor=", vec_predictor, 
                            ", controls=", vec_controls))

# custom function
# random intercept model:
lmer_ri_1 <- function(formula, data,...) {
  require(lme4)
  require(broom.mixed)
  formula <- paste(formula, "+ (1|country_str)")
  lme4::lmer(formula, data)
}
lmer_ri_2 <- function(formula, data,...) {
  require(lmerTest)
  require(broom.mixed)
  formula <- paste(formula, "+ (1|country_str)")
  lmerTest::lmer(formula, data)
}

# Including random slopes (country as grouping variable -> as preregistered)
lmer_rs_1 <- function(formula, data,...) {
  require(lme4)
  require(broom.mixed)
  slopevars <- word(unlist(strsplit(formula, " ~ "))[2], 1, sep=fixed(" + ")) # only 1 random slope (of 'group' var)
  formula <- paste0(formula, "+ (1 + ", slopevars, "|country_str)" )
  lme4::lmer(formula, data, control=lmerControl(optimizer="bobyqa",
                                                optCtrl=list(maxfun=2e5)))
}
lmer_rs_2 <- function(formula, data,...) {
  require(lmerTest)
  require(broom.mixed)
  slopevars <- word(unlist(strsplit(formula, " ~ "))[2], 1, sep=fixed(" + "))
  formula <- paste0(formula, "+ (1 + ", slopevars, "|country_str)" )
  lmerTest::lmer(formula, data, control=lmerControl(optimizer="bobyqa",
                                                optCtrl=list(maxfun=2e5)))
}

# personality
# Setup Specifications
specs_b5 <- specr::setup(data = df_singles, 
                  y = c("extraversion", "agreeableness_w", "conscientiousness_w", "neuroticism", "openness"), 
                  x = c("never_partnered", "never_cohabitating", "never_married"), 
                  controls = c("age_c", "female", "income_z", "education", 
                               "religiosity_z", "gender_ratio_z", "singles_proportion_z"),
                  simplify = T, # not all combinations of covars
                  model = c("lmer_rs_1"))

# identical, but with p-values pls
specs_b5_p <- specr::setup(data = df_singles, 
                  y = c("extraversion", "agreeableness_w", "conscientiousness_w", "neuroticism", "openness"), 
                  x = c("never_partnered", "never_cohabitating", "never_married"), 
                  controls = c("age_c", "female", "income_z", "education", 
                               "religiosity_z", "gender_ratio_z", "singles_proportion_z"),
                  simplify = T, # not all combinations of covars
                  model = c("lmer_rs_2"))

# Run Specification Curve Analysis
#opts <- furrr_options( # for parallelization (using multiple cores)
#  globals = list(lmer_rs_1 = lmer_rs_1)
#)
#plan(strategy = multisession, workers = 6)
sca_b5 <- specr(specs_b5) 
                #.options = opts,   # Pass opts to specr
                #.progress = TRUE)
sca_b5_p <- specr(specs_b5_p) # run again (for p-values)

# well-being
# Setup Specifications
specs_wb <- specr::setup(data = df_singles, 
                         y = c("life_satisfaction_p", "quality_of_life_p", "casp_alt_p"), 
                         x = c("never_partnered", "never_cohabitating", "never_married"), 
                         controls = c("age_c", "female", "income_z", "education", 
                                      "religiosity_z", "gender_ratio_z", "singles_proportion_z"),
                         simplify = T, # not all combinations of covars
                         model = c("lmer_rs_1"))

# identical, but with p-values pls
specs_wb_p <- specr::setup(data = df_singles, 
                         y = c("life_satisfaction_p", "quality_of_life_p", "casp_alt_p"), 
                         x = c("never_partnered", "never_cohabitating", "never_married"), 
                         controls = c("age_c", "female", "income_z", "education", 
                                      "religiosity_z", "gender_ratio_z", "singles_proportion_z"),
                         simplify = T, # not all combinations of covars
                         model = c("lmer_rs_2"))

# Run Specification Curve Analysis
sca_wb <- specr(specs_wb) 
                #.options = opts,
                #.progress = TRUE)
sca_wb_p <- specr(specs_wb_p) # run again (for p-values)

#plan(sequential) # stop parallelization
```

SCA for personality traits:
```{r}
#| echo: true
#| fig-width: 9.5
#| fig-height: 7.5

# Plot Specification Curve
plot(sca_b5, 
     choices = c("x", "y", "controls"))
```

Summary of entire SCA:
```{r}
#| echo: true
summary(sca_b5)
```

SCA for well-being:
```{r}
#| echo: true
#| fig-width: 9.5
#| fig-height: 7.5

# Plot Specification Curve
plot(sca_wb, 
     choices = c("x", "y", "controls"))
```

Summary of entire SCA:
```{r}
#| echo: true
summary(sca_wb)
```

Important for interpretation: Unlike for personality, I used POMP (percentage of maximum possible) scores here to make the results comparable across the two well-being operationalizations.  

### Results summary

#### Hypothesis 1: Extraversion {#hyp1}

*Lifelong singles self-report lower levels of extraversion as compared to partnered individuals.* 

All model results for extraversion:
```{r}
#| echo: true
kable(sca_b5_p$data %>% filter(y=="extraversion") %>% 
        select(x, controls, estimate, conf.low, conf.high, std.error, statistic, p.value, fit_nobs), digits = 3)
```

Median effect size:
```{r}
#| echo: true
sca_b5$data %>% filter(y=="extraversion") %>% 
  group_by(x) %>% 
  summarise(median_est = median(estimate), median_conf.low = median(conf.low), median_conf.high = median(conf.high))
```

::: {.callout-note appearance="minimal"}
Negative effect for extraversion that does not depend much on the set of control variables. The effect is a bit stronger when looking at people who were never in a committed relationship or never cohabited with a partner compared to those who were never married.
:::

#### Hypothesis 2: Neuroticism {#hyp2}

*Lifelong singles self-report higher levels of neuroticism as compared to partnered individuals.* 

All model results for neuroticism:
```{r}
#| echo: true
kable(sca_b5_p$data %>% filter(y=="neuroticism") %>% 
        select(x, controls, estimate, conf.low, conf.high, std.error, statistic, p.value, fit_nobs), digits = 3)
```

Median effect size:
```{r}
#| echo: true
sca_b5$data %>% filter(y=="neuroticism") %>% 
  group_by(x) %>% 
  summarise(median_est = median(estimate), median_conf.low = median(conf.low), median_conf.high = median(conf.high))
```

::: {.callout-note appearance="minimal"}
No effect for neuroticism.
:::

#### Hypothesis 3: Conscientiousness {#hyp3}

*Lifelong singles self-report lower levels of conscientiousness as compared to partnered individuals.* 

All model results for conscientiousness:
```{r}
#| echo: true
kable(sca_b5_p$data %>% filter(y=="conscientiousness_w") %>% 
        select(x, controls, estimate, conf.low, conf.high, std.error, statistic, p.value, fit_nobs), digits = 3)
```

Median effect size:
```{r}
#| echo: true
sca_b5$data %>% filter(y=="conscientiousness_w") %>% 
  group_by(x) %>% 
  summarise(median_est = median(estimate), median_conf.low = median(conf.low), median_conf.high = median(conf.high))
```

::: {.callout-note appearance="minimal"}
Quite consistent effect for conscientiousness that is a bit smaller than the one for extraversion but is relatively similar across all the different specifications. Again, no strong influence of the covariates on the results.
:::

#### Hypothesis 4: Well-being / Life Satisfaction {#hyp4}

*Lifelong singles self-report lower levels of life satisfaction as compared to partnered individuals.* 

Important for interpretation: Unlike for personality, I used POMP (percentage of maximum possible) scores here to make the results comparable across the two well-being operationalizations.  

All model results for well-being:
```{r}
#| echo: true
kable(sca_wb_p$data %>% filter(y %in% c("life_satisfaction_p", "quality_of_life_p")) %>% 
        select(y, x, controls, estimate, conf.low, conf.high, statistic, p.value, fit_nobs), digits = 3)
```

Median effect size:
```{r}
#| echo: true
sca_wb$data %>% filter(y %in% c("life_satisfaction_p", "quality_of_life_p")) %>% 
  group_by(y, x) %>% 
  summarise(median_est = median(estimate), median_conf.low = median(conf.low), median_conf.high = median(conf.high))
```

::: {.callout-note appearance="minimal"}
Substantial effect for both life satisfaction and quality of life. The effect is somewhat stronger for life satisfaction and, again (as for extraversion), for those who were never in a committed relationship or never cohabited with a partner compared to those who were never married. Controlling for covariates (e.g., income, age) does make a substantial difference here.
:::

Alternative missingness strategy for quality of life (CASP-12 scale): use all observations with 8 or more valid item answers
```{r}
#| echo: true
kable(sca_wb_p$data %>% filter(y %in% c("casp_alt_p")) %>% 
        select(y, x, controls, estimate, conf.low, conf.high, statistic, p.value, fit_nobs), digits = 3)
```

Median effect size:
```{r}
#| echo: true
sca_wb$data %>% filter(y %in% c("casp_alt_p")) %>% 
  group_by(y, x) %>% 
  summarise(median_est = median(estimate), median_conf.low = median(conf.low), median_conf.high = median(conf.high))
```

::: {.callout-note appearance="minimal"}
Very similar overall results!
:::

## Exploratory results

Differences in openness for experiences and agreeableness between lifelong singles and partnered individuals will be investigated in an exploratory manner.  

### Agreeableness

All model results:
```{r}
#| echo: true
kable(sca_b5_p$data %>% filter(y=="agreeableness_w") %>% 
        select(x, controls, estimate, conf.low, conf.high, std.error, statistic, p.value, fit_nobs), digits = 3)
```

Median effect size:
```{r}
#| echo: true
sca_b5$data %>% filter(y=="agreeableness_w") %>% 
  group_by(x) %>% 
  summarise(median_est = median(estimate), median_conf.low = median(conf.low), median_conf.high = median(conf.high))
```

::: {.callout-note appearance="minimal"}
Small effects that are not significant at *p* = .005. (These were significant in the random intercept models.) 
:::

### Openness to experiences

All model results:
```{r}
#| echo: true
kable(sca_b5_p$data %>% filter(y=="openness") %>% 
        select(x, controls, estimate, conf.low, conf.high, std.error, statistic, p.value, fit_nobs), digits = 3)
```

Median effect size:
```{r}
#| echo: true
sca_b5$data %>% filter(y=="openness") %>% 
  group_by(x) %>% 
  summarise(median_est = median(estimate), median_conf.low = median(conf.low), median_conf.high = median(conf.high))
```

::: {.callout-note appearance="minimal"}
Small effect that is only consistently significant for those never in a relationship. For those who never cohabitated it depends on the included controls whether the effect is significant at *p* = .005 (just barely below that threshold when controlling for age). 
:::

### Moderator analyses: age, income

*We will also investigate potential moderator variables for all hypothesized effects, as well as for openness for experiences and agreeableness.*  

In additional analyses, using multilevel regression models, we will investigate whether the relationship between singlehood and Big 5 personality traits or life satisfaction is moderated by participants' age or income / SES.

Run models:
```{r}
#| echo: true
#| warning: false
#| output: false
#| code-fold: true
#| code-summary: "Show the code"
#| cache: true

df_singles <- df_singles %>% rename()

# custom function
lmer_cust_int_moder = function(outcome, predictor, moderator, df, random_slope=FALSE) {
  
  if (random_slope==TRUE) {
    form = as.formula(paste0(outcome, " ~ 1 + ", predictor, "*", moderator, 
                             " + (1 + ", predictor, " | country_str)"))
  }
  else {
    form = as.formula(paste0(outcome, " ~ 1 + ", predictor, "*", moderator, " + (1 | country_str)"))
  }
  lmerTest::lmer(form, data = get(df), control=lmerControl(optimizer="bobyqa",
                                                optCtrl=list(maxfun=2e5)))
}

outcomes <- as.list(c(rep("extraversion", 6), rep("agreeableness_w", 6), rep("conscientiousness_w", 6), 
                      rep("neuroticism", 6), rep("openness", 6), 
                      rep("life_satisfaction_p", 6), rep("quality_of_life_p", 6)))
predictors <- as.list(rep(c("never_partnered", "never_cohabitating", "never_married"), 14))
moderators <- as.list(rep(c("age_c", "age_c", "age_c", "income_z", "income_z", "income_z"), 7))
df_names <- rep(list("df_singles"), 42)
slopes_fr <- rep(list(TRUE), 42) 
combinations <- list(outcomes=outcomes, predictors=predictors, moderators=moderators, df_names=df_names, slopes_fr=slopes_fr)

# run models
mods_expl_moder <- combinations %>% 
  purrr::pmap(~with(list(...), lmer_cust_int_moder(outcomes, predictors, moderators, df_names, slopes_fr)))
names(mods_expl_moder) <- paste(unlist(outcomes), unlist(predictors), unlist(moderators), sep = "_")

# create summary df
summary_mods_expl_moder <- mods_expl_moder[[1]] %>% tidy() %>% 
  filter(str_detect(term, ":")) %>% 
  mutate(outcome = stringr::word(names(mods_expl_moder)[1], 1, sep = "_")) %>% 
  select(outcome, term, estimate, std.error, p.value)

for (i in 2:length(mods_expl_moder)) {
  # loop over all models
  row_to_add <- mods_expl_moder[[i]] %>% tidy() %>% 
  filter(str_detect(term, ":")) %>% 
  mutate(outcome = stringr::word(names(mods_expl_moder)[i], 1, sep = "_")) %>% 
  select(outcome, term, estimate, std.error, p.value)
  # add rows
  summary_mods_expl_moder <- bind_rows(summary_mods_expl_moder, row_to_add)
}
```

Summary of results: Extraversion
```{r}
#| echo: true
summary_mods_expl_moder %>% filter(outcome=="extraversion") %>% kable(., digits = 3)
```

Summary of results: Agreeableness
```{r}
#| echo: true
summary_mods_expl_moder %>% filter(outcome=="agreeableness") %>% kable(., digits = 3)
```

Summary of results: Conscientiousness
```{r}
#| echo: true
summary_mods_expl_moder %>% filter(outcome=="conscientiousness") %>% kable(., digits = 3)
```

Summary of results: Neuroticism
```{r}
#| echo: true
summary_mods_expl_moder %>% filter(outcome=="neuroticism") %>% kable(., digits = 3)
```

Summary of results: Openness
```{r}
#| echo: true
summary_mods_expl_moder %>% filter(outcome=="openness") %>% kable(., digits = 3)
```

Summary of results: Life satisfaction
```{r}
#| echo: true
summary_mods_expl_moder %>% filter(outcome=="life") %>% kable(., digits = 3)
```

Summary of results: Quality of life
```{r}
#| echo: true
summary_mods_expl_moder %>% filter(outcome=="quality") %>% kable(., digits = 3)
```

::: {.callout-note appearance="minimal"}
Only moderation that is consistently significant at *p* = .005 is for life satisfaction and age. Some inconsistent effects for conscientiousness (with the predictor "never cohabitating" and moderator income) and for neuroticism (with the predictor "never partnered" and moderator age).
:::

### Moderator analyses: country-level variables

*Further, although there is some evidence for cross-country or cross-cultural differences in the association between being single and life satisfaction. Thus, we investigate this association in an exploratory manner as well.*

For the geographical analyses, we will investigate differences in life satisfaction and Big 5 personality traits among singles vs. non-singles regarding the country level variables (from the countries they are currently living in) religiosity, gender ratio and single ratio (level-2 variables). More precisely, we will investigate cross-level interaction effects of these level-2 variables with 'group'.

Run models:
```{r}
#| echo: true
#| warning: false
#| output: false
#| code-fold: true
#| code-summary: "Show the code"
#| cache: true

# custom function
lmer_cust_int_cntr = function(outcome, predictor, moderator, df, random_slope=FALSE) {
  
  if (random_slope==TRUE) {
    form = as.formula(paste0(outcome, " ~ 1 + ", predictor, "*", moderator, 
                             " + (1 + ", predictor, " | country_str)"))
  }
  else {
    form = as.formula(paste0(outcome, " ~ 1 + ", predictor, "*", moderator, " + (1 | country_str)"))
  }
  lmerTest::lmer(form, data = get(df), control=lmerControl(optimizer="bobyqa",
                                                optCtrl=list(maxfun=2e5)))
}

outcomes <- as.list(c(rep("extraversion", 9), rep("agreeableness_w", 9), rep("conscientiousness_w", 9), 
                      rep("neuroticism", 9), rep("openness", 9), rep("life_satisfaction_p", 9), rep("quality_of_life_p", 9)))
predictors <- as.list(rep(c("never_partnered", "never_cohabitating", "never_married"), 21))
moderators <- as.list(rep(c("religiosity_z", "religiosity_z", "religiosity_z", 
                            "gender_ratio_z", "gender_ratio_z", "gender_ratio_z",
                            "singles_proportion_z", "singles_proportion_z", "singles_proportion_z"), 7))
df_names <- rep(list("df_singles"), 63)
slopes_fr <- rep(list(TRUE), 63) 
combinations <- list(outcomes=outcomes, predictors=predictors, moderators=moderators, df_names=df_names, slopes_fr=slopes_fr)

# run models
mods_expl_cntr <- combinations %>% purrr::pmap(~with(list(...), lmer_cust_int_cntr(outcomes, predictors, moderators, df_names, slopes_fr)))
names(mods_expl_cntr) <- paste(unlist(outcomes), unlist(predictors), unlist(moderators), sep = "_")

# create summary df
summary_mods_expl_cntr <- mods_expl_cntr[[1]] %>% tidy() %>% 
  filter(str_detect(term, ":")) %>% 
  mutate(outcome = stringr::word(names(mods_expl_cntr)[1], 1, sep = "_")) %>% 
  select(outcome, term, estimate, std.error, p.value)

for (i in 2:length(mods_expl_cntr)) {
  # loop over all models
  row_to_add <- mods_expl_cntr[[i]] %>% tidy() %>% 
  filter(str_detect(term, ":")) %>% 
  mutate(outcome = stringr::word(names(mods_expl_cntr)[i], 1, sep = "_")) %>% 
  select(outcome, term, estimate, std.error, p.value)
  # add rows
  summary_mods_expl_cntr <- bind_rows(summary_mods_expl_cntr, row_to_add)
}
```

Summary of results: Extraversion
```{r}
#| echo: true
summary_mods_expl_cntr %>% filter(outcome=="extraversion") %>% kable(., digits = 3)
```

Summary of results: Agreeableness
```{r}
#| echo: true
summary_mods_expl_cntr %>% filter(outcome=="agreeableness") %>% kable(., digits = 3)
```

Summary of results: Conscientiousness
```{r}
#| echo: true
summary_mods_expl_cntr %>% filter(outcome=="conscientiousness") %>% kable(., digits = 3)
```

Summary of results: Neuroticism
```{r}
#| echo: true
summary_mods_expl_cntr %>% filter(outcome=="neuroticism") %>% kable(., digits = 3)
```

Summary of results: Openness
```{r}
#| echo: true
summary_mods_expl_cntr %>% filter(outcome=="openness") %>% kable(., digits = 3)
```

Summary of results: Life satisfaction
```{r}
#| echo: true
summary_mods_expl_cntr %>% filter(outcome=="life") %>% kable(., digits = 3)
```

Summary of results: Quality of life
```{r}
#| echo: true
summary_mods_expl_cntr %>% filter(outcome=="quality") %>% kable(., digits = 3)
```

::: {.callout-note appearance="minimal"}
Cross-level moderation effects that are significant at *p* = .005 are present for neuroticism and gender ratio as well as proportion of singles, life satisfaction and religiosity, and quality of life and gender ratio as well as proportion of singles (and also religiosity for those never partnered). 
:::

### Moderator analyses: personality as a moderator of well-being effects

Analyzing the extent to which the personality differences account for the well-being differences.

Run models:
```{r}
#| echo: true
#| warning: false
#| output: false
#| code-fold: true
#| code-summary: "Show the code"
#| cache: true
#| include: true

# custom function
lmer_cust_int_pers = function(outcome, predictor, moderator, df, random_slope=FALSE) {
  
  if (random_slope==TRUE) {
    form = as.formula(paste0(outcome, " ~ 1 + ", predictor, "*", moderator, 
                             " + (1 + ", predictor, " | country_str)"))
  }
  else {
    form = as.formula(paste0(outcome, " ~ 1 + ", predictor, "*", moderator, " + (1 | country_str)"))
  }
  lmerTest::lmer(form, data = get(df), control=lmerControl(optimizer="bobyqa",
                                                optCtrl=list(maxfun=2e5)))
}

outcomes <- as.list(c(rep("life_satisfaction_p", 15), rep("quality_of_life_p", 15)))
predictors <- as.list(rep(c("never_partnered", "never_cohabitating", "never_married"), 10))
moderators <- as.list(rep(c(rep("extraversion", 3), rep("agreeableness_w", 3), 
                            rep("conscientiousness_w", 3), rep("neuroticism", 3), 
                            rep("openness", 3)), 2))
df_names <- rep(list("df_singles"), 30)
slopes_fr <- rep(list(TRUE), 30) 
combinations <- list(outcomes=outcomes, predictors=predictors, moderators=moderators, df_names=df_names, slopes_fr=slopes_fr)

# run models
mods_expl_pers <- combinations %>% purrr::pmap(~with(list(...), lmer_cust_int_pers(outcomes, predictors, moderators, df_names, slopes_fr)))
names(mods_expl_pers) <- paste(unlist(outcomes), unlist(predictors), unlist(moderators), sep = "_")

# create summary df
summary_mods_expl_pers <- mods_expl_pers[[1]] %>% tidy() %>% 
  filter(str_detect(term, ":")) %>% 
  mutate(outcome = stringr::word(names(mods_expl_pers)[1], 1, sep = "_")) %>% 
  select(outcome, term, estimate, std.error, p.value)

for (i in 2:length(mods_expl_pers)) {
  # loop over all models
  row_to_add <- mods_expl_pers[[i]] %>% tidy() %>% 
  filter(str_detect(term, ":")) %>% 
  mutate(outcome = stringr::word(names(mods_expl_pers)[i], 1, sep = "_")) %>% 
  select(outcome, term, estimate, std.error, p.value)
  # add rows
  summary_mods_expl_pers <- bind_rows(summary_mods_expl_pers, row_to_add)
}
```

Summary of results: Life satisfaction
```{r}
#| echo: true
summary_mods_expl_pers %>% filter(outcome=="life") %>% kable(., digits = 3)
```

Summary of results: Quality of life
```{r}
#| echo: true
summary_mods_expl_pers %>% filter(outcome=="quality") %>% kable(., digits = 3)
```

::: {.callout-note appearance="minimal"}
For life satisfaction, there is evidence for moderation of the association with singlehood by the personality traits extraversion (only "never cohabitating"), agreeableness (all three indicators), conscientiousness (only "never partnered" and suggestive evidence for "never cohabitating"), and neuroticsm ("never married", "never cohabitating", and suggestive evidence for "never partnered").
:::

::: {.callout-note appearance="minimal"}
For quality of life, effects are somewhat similar. There is evidence for moderation of the association with singlehood by the personality traits extraversion (only "never cohabitating"), conscientiousness (only "never partnered"), and neuroticsm ("never married" and suggestive evidence for "never cohabitating"). No significant moderation effects for agreeableness, though. 
:::

### Proportion of explained variance in well-being due to singlehood status vs. personality

Run models:
```{r}
#| echo: true
#| warning: false
#| output: false
#| code-fold: true
#| code-summary: "Show the code"
#| cache: true
#| include: true

# life satisfaction 
expl_variance_ls_partnered <- 
  lmerTest::lmer(life_satisfaction_p ~ 1 + never_partnered + (1 | country_str), 
                 data = df_singles, control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))

expl_variance_ls_b5 <- 
  lmerTest::lmer(life_satisfaction_p ~ 1 + extraversion + agreeableness_w + conscientiousness_w + neuroticism + openness + (1 | country_str), 
                 data = df_singles, control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))

expl_variance_ls_partnered_b5 <- 
  lmerTest::lmer(life_satisfaction_p ~ 1 + never_partnered + 
                   extraversion + agreeableness_w + conscientiousness_w + neuroticism + openness + (1 | country_str), 
                 data = df_singles, control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))

expl_variance_ls_cohabitating <- 
  lmerTest::lmer(life_satisfaction_p ~ 1 + never_cohabitating + (1 | country_str), 
                 data = df_singles, control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))

expl_variance_ls_cohabitating_b5 <- 
  lmerTest::lmer(life_satisfaction_p ~ 1 + never_cohabitating + 
                   extraversion + agreeableness_w + conscientiousness_w + neuroticism + openness + (1 | country_str), 
                 data = df_singles, control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))

expl_variance_ls_married <- 
  lmerTest::lmer(life_satisfaction_p ~ 1 + never_married + (1 | country_str), 
                 data = df_singles, control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))

expl_variance_ls_married_b5 <- 
  lmerTest::lmer(life_satisfaction_p ~ 1 + never_married + 
                   extraversion + agreeableness_w + conscientiousness_w + neuroticism + openness + (1 | country_str), 
                 data = df_singles, control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))

# quality of life
expl_variance_qual_partnered <- 
  lmerTest::lmer(quality_of_life_p ~ 1 + never_partnered + (1 | country_str), 
                 data = df_singles, control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))

expl_variance_qual_b5 <- 
  lmerTest::lmer(quality_of_life_p ~ 1 + extraversion + agreeableness_w + conscientiousness_w + neuroticism + openness + (1 | country_str), 
                 data = df_singles, control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))

expl_variance_qual_partnered_b5 <- 
  lmerTest::lmer(quality_of_life_p ~ 1 + never_partnered + 
                   extraversion + agreeableness_w + conscientiousness_w + neuroticism + openness + (1 | country_str), 
                 data = df_singles, control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))

expl_variance_qual_cohabitating <- 
  lmerTest::lmer(quality_of_life_p ~ 1 + never_cohabitating + (1 | country_str), 
                 data = df_singles, control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))

expl_variance_qual_cohabitating_b5 <- 
  lmerTest::lmer(quality_of_life_p ~ 1 + never_cohabitating + 
                   extraversion + agreeableness_w + conscientiousness_w + neuroticism + openness + (1 | country_str), 
                 data = df_singles, control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))

expl_variance_qual_married <- 
  lmerTest::lmer(quality_of_life_p ~ 1 + never_married + (1 | country_str), 
                 data = df_singles, control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))

expl_variance_qual_married_b5 <- 
  lmerTest::lmer(quality_of_life_p ~ 1 + never_married + 
                   extraversion + agreeableness_w + conscientiousness_w + neuroticism + openness + (1 | country_str), 
                 data = df_singles, control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
```

"For mixed models, the conditional and marginal R-squared are returned. The marginal R-squared considers only the variance of the fixed effects and indicates how much of the model’s variance is explained by the fixed effects part only. The conditional R-squared takes both the fixed and random effects into account and indicates how much of the model’s variance is explained by the “complete” model.", see https://easystats.github.io/performance/

Summary of results: Life satisfaction
```{r}
#| echo: true

# never partnered
kable(compare_performance(expl_variance_ls_partnered, expl_variance_ls_b5, expl_variance_ls_partnered_b5, verbose = FALSE)[c("Name", "AIC", "BIC", "R2_conditional", "R2_marginal", "ICC", "RMSE", "Sigma")], digits = 3)

# never cohabitating
kable(compare_performance(expl_variance_ls_cohabitating, expl_variance_ls_b5, expl_variance_ls_cohabitating_b5, verbose = FALSE)[c("Name", "AIC", "BIC", "R2_conditional", "R2_marginal", "ICC", "RMSE", "Sigma")], digits = 3)

# never married
kable(compare_performance(expl_variance_ls_married, expl_variance_ls_b5, expl_variance_ls_married_b5, verbose = FALSE)[c("Name", "AIC", "BIC", "R2_conditional", "R2_marginal", "ICC", "RMSE", "Sigma")], digits = 3)
```

Summary of results: Quality of life
```{r}
#| echo: true
# never partnered
kable(compare_performance(expl_variance_qual_partnered, expl_variance_qual_b5, expl_variance_qual_partnered_b5, verbose = FALSE)[c("Name", "AIC", "BIC", "R2_conditional", "R2_marginal", "ICC", "RMSE", "Sigma")], digits = 3)

# never cohabitating
kable(compare_performance(expl_variance_qual_cohabitating, expl_variance_qual_b5, expl_variance_qual_cohabitating_b5, verbose = FALSE)[c("Name", "AIC", "BIC", "R2_conditional", "R2_marginal", "ICC", "RMSE", "Sigma")], digits = 3)

# never married
kable(compare_performance(expl_variance_qual_married, expl_variance_qual_b5, expl_variance_qual_married_b5, verbose = FALSE)[c("Name", "AIC", "BIC", "R2_conditional", "R2_marginal", "ICC", "RMSE", "Sigma")], digits = 3)
```

